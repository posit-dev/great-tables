---
title: Extending Great Tables
format: html
---

<!-- Intro -->
The **Great Tables** package boasts a diverse range of methods for your creation of beautiful tables. With no shortage of tools, styles, formats and themes, you can produce a very wide range of tables. If you haven't yet, head over to the [examples gallery](../examples/index.qmd) for a flavor of the variety that is possible.

But what happens when there's something you want to add to your table, but it's not directly supported by **Great Tables**? Let's say you have a very specific use case for your great table, so it's not necessarily broad enough to [contribute to the package](contributing.qmd). Or maybe it *is* generalizable, but it's beyond the scope of what you want to do. There are plenty of reasons to want a specific feature for your table that doesn't warrant a pull request.

[**gt-extras**](https://posit-dev.github.io/gt-extras/) is a great case study in this, filling some table goals that aren't supported by **Great Tables** directly.

## Writing an Extension Function

When extending **Great Tables**, you have two main approaches: *wrappers* and *extensions*. Understanding the distinction between these approaches will help you choose the right strategy for your use case.

- **Wrappers** simplify existing functionality by bundling common parameter combinations into convenient functions. They don't add new capabilities, but make complex styling or formatting tasks more accessible.
- **Extensions**, on the other hand, add new functionality by combining multiple methods in creative ways, processing data outside the package, or generating custom content (like HTML or images) that gets integrated into your table.

Both approaches are valuable contributions to the **Great Tables** ecosystem, and the choice between them depends on whether you're making it easier to access existing tooling or creating entirely new capabilities.

### gt-extras

Some of the functions in [**gt-extras**](https://posit-dev.github.io/gt-extras/) are wrappers. Take [`gt_highlight_cols()`](https://posit-dev.github.io/gt-extras/reference/gt_highlight_cols), which is a wrapper function that doesn't add *new* functionality to **Great Tables**. If you look at the underlying code, you'll see it makes a call to `~~GT.tab_style()`, while setting specific `locations=` and `style=` parameters. Something as lightweight as this might be useful for someone who knows what effect they want, but doesn't want to investigate the entire space of options for styling.

<!-- Show code here maybe? -->

```{python}
# | eval: False
# | code-fold: true
# | code-summary: "Show the code"
# Select locations based on the parameters in scope at this point of the function
locations: list[Loc] = [loc.body(columns=columns)]
if include_column_labels:
    locations.append(loc.column_labels(columns=columns))

# Select styles according to fill, font_weight, and font_color parameters
styles: list[CellStyle] = [
    style.fill(color=fill),
    style.borders(color=fill),
    style.text(weight=font_weight, color=font_color),
]

# Make the wrapped tab_style call
gt = gt.tab_style(
    style=styles,
    locations=locations,
)
```


**gt-extras** also extends the customizing of tables, beyond making existing methods even more convenient to use. For example [`gt_two_column_layout()`](https://posit-dev.github.io/gt-extras/reference/gt_two_column_layout) does a little more heavy lifting, building an HTML string containing two side-by-side tables. This function takes two separate `~~GT` objects, renders them as HTML using `~~GT.as_raw_html()`, and then wraps them in custom HTML structure to create a unified side-by-side layout, which would not be possible with **Great Tables** methods alone.

```{python}
# | eval: False
# | code-fold: true
# | code-summary: "Show the code"
# In one of the branched of `gt_two_column_layout`, a header isn't set
header_html = ""
table_1_html = gt1.as_raw_html()
table_2_html = gt2.as_raw_html()

# Great Tables is extended via supplemental html
double_table_html = f"""
    <div style="display: flex; justify-content: center; width: 100%;">
        <div id="mycombinedtable" style="display: inline-block; width: auto;">
            {header_html}
            <div style="overflow: auto; white-space: nowrap;">
                <div style="display: inline-block; margin-right: 1em;">
                    {table_1_html}
                </div>
                <div style="display: inline-block;">
                    {table_2_html}
                </div>
            </div>
        </div>
    </div>
    """
```


## Great Tables Extension Possibilities

What might you want to put into an extension to **Great Tables**? Here are some of the most common and impactful areas where extensions can add significant value to your tables.

### Plots

Also known as sparklines, embedded plots in tables are a powerful tool. So much so that some plotting is already built in, called [nanoplots](nanoplots.qmd). But there are endless plot types you could want in your great tables, and for these `~~GT.fmt()` is your friend.

The key to adding custom plots to your tables is using `~~GT.fmt()` with a function that converts your data values into visual representations. Your formatting function should take a value from your table and return an HTML string containing your plot—whether that's an SVG, a series of styled `<div>` elements, or even embedded images.

Here's the basic pattern for a plot extension:

```{python}
# | eval: False
def create_my_plot(value):
    # Transform the data value into a visual representation
    # This could use any plotting library or even pure HTML/CSS
    plot_html = f"<svg>...</svg>"  # Your plot generation logic here
    return plot_html


# Apply to your table
gt.fmt(fns=create_my_plot, columns="my_data_column")
```

Check out this [blog post](../blog/plots-in-tables/index.qmd)  for a deeper dive into different approaches for creating plots in tables.

### Themes

This is where wrapper functions really shine. Maybe you want a very standardized look, or you want all of your tables to mimic your favorite one. Take advantage of `~~GT.tab_options()` for your own [premade themes](./table-theme-premade.qmd), with styles from any of the [table theme options](./table-theme-options.qmd) of your choosing.

Here's how **gt-extras** implemented the [ESPN](https://posit-dev.github.io/gt-extras/reference/gt_theme_espn) theme:

```{python}
# | eval: False
gt_theme_espn = (
    gt.opt_all_caps()
    .opt_table_font(font=google_font("Lato"), weight=400)
    .opt_row_striping()
    .tab_style(style=style.text(weight="bold"), locations=loc.column_header())
    .tab_options(
        row_striping_background_color="#fafafa",
        table_body_hlines_color="#f6f7f7",
        source_notes_font_size="12px",
        table_font_size="16px",
        heading_align="left",
        heading_title_font_size="24px",
        table_border_top_color="white",
        table_border_top_width="3px",
        data_row_padding="7px",
    )
)
```

### Icons

They say a picture is worth a thousand words. So maybe you want to take `~~GT.fmt_icon()` and run with it, but with your own custom icon sets or specialized styling needs. For example:

- **Create domain-specific icon mappings**: Automatically map data values to meaningful icons (like status indicators, ratings, or categories)
- **Apply custom styling**: Add animations, colors, or hover effects to your icons

Here's an example of how you might create a custom icon extension that maps numerical ratings to star icons:

```{python}
# | eval: False
def fmt_star_rating(filled_stars: int, max_stars=5):
    empty_stars = max_stars - filled_stars

    star_html = "★" * filled_stars + "☆" * empty_stars
    return f'<span style="color: gold; font-size: 18px;">{star_html}</span>'


# Apply to your table, again `fmt()` comes in handy!
gt.fmt(fns=fmt_star_rating, columns="my_data_column")
```

### Beyond

Go where your heart desires, you aren't constrained by what is provided by this package, in fact, this package is just the beginning of your tabling life!
