---
title: "Adding Plots to Great Tables"
html-table-processing: none
author: Jules Walzer-Goldfeld and Michael Chow
date: 2025-07-02
jupyter: python3
---

While working on **gt-extras**, I've been exploring how to add small plots to Great Tables. These can go by many names, like spark lines, nanoplots, and so on. In this post, I'll look at three approaches I tried: adding plots with `plotnine`, `svg.py`, or adding HTML directly. In the first two cases, the plots are SVGs, while the latter entails a collection of composed HTML div elements.

Here's are the pieces I'll cover:

* **plotnine**: adding a full, stripped-down chart to a row.
* **svg.py**: creating your own tiny chart directly for a row.
* **direct HTML**: adding HTML divs directly.

In the end, it's often simplest to use `svg.py`, since you can create simple charts with minimal overhead. Building elements with HTML has less overhead, but is slightly less user-friendly. On the other end of the spectrum, as your chart grows in complexity, using existing packages like the more exhaustive `plotnine` are good alternatives.


```{python}
# | echo: false
import polars as pl

from plotnine import ggplot, aes, geom_bar, coord_flip, geom_col, expand_limits
from great_tables import GT

df = pl.DataFrame({"Animal": ["Ostrich", "Spider", "Lion"], "Legs": [2, 8, 4], "Plot": [2, 8, 4]})

gt = GT(df)
gt
```

Here is the final result:

```{python}
# | code-fold: true
import polars as pl
from great_tables import GT

df = pl.DataFrame({"Animal": ["Ostrich", "Spider", "Lion"], "Legs": [2, 8, 4], "Plot": [2, 8, 4]})

width = 50
height = 30
max_legs_value = df["Legs"].max()


def create_plot_html(val: int) -> str:
    bar_element = f"""
    <div style="position: absolute;
                width: {width * val / max_legs_value}px;
                height: {height / 2}px;
                background-color: purple;
                margin-top: {height / 4}px;
    "></div>"""

    line_element = """
    <div style="position: absolute;
                top: 0;
                bottom: 0;
                width: 1px;
                background-color: black;
    "></div>"""

    html = f"""
    <div style="position: relative; width: {width}px; height: {height}px;">
        {bar_element}
        {line_element}
    </div>
    """

    return html


GT(df).fmt(fns=create_plot_html, columns=["Plot"])
```

## Setup

Here is the code to start:

```{python}
import polars as pl
from great_tables import GT

df = pl.DataFrame(
    {
        "Animal": ["Ostrich", "Spider", "Lion"],
        "Legs": [2, 8, 4],
        "Plot": [2, 8, 4],
    }
)

gt = GT(df)
```


## The Binding Component: gt.fmt()

Let's take advantage of the [`fmt()`](https://posit-dev.github.io/great-tables/reference/GT.fmt.html#great_tables.GT.fmt) method to apply a plotting function that formats our row values into plots. To see how we might use `fmt()`, we first need to define a formatting function to apply to each cell in a column. It will take as input the value in the cell, and should return whatever you want in that cell. Before plotting, let's imagine we wanted to tally the number of legs using `fmt()`:

```{python}
def create_leg_tally(value: int) -> str:
    return "|" * value


gt.fmt(fns=create_leg_tally, columns="Plot")
```


## A Comprehensive Package: Plotnine

Now we can apply that same logic to making our plots. Let's start with the function that will eventually be passed into `fmt()`:

```{python}
from io import StringIO
from plotnine import (
    ggplot,
    aes,
    coord_flip,
    geom_col,
    scale_y_continuous,
    scale_x_continuous,
    theme_void,
    geom_hline,
)

max_legs_value = df["Legs"].max()


def create_plot_plotnine(val: int) -> str:
    plot = (
        ggplot()
        + aes(x=1, y=val)
        + geom_col(width=0.5, fill="green", show_legend=False)
        + scale_y_continuous(limits=(0, max_legs_value))
        + scale_x_continuous(limits=(0.5, 1.5))
        + coord_flip()
        + theme_void()
        + geom_hline(yintercept=0)
    )

    buf = StringIO()
    plot.save(buf, format="svg", width=0.5, height=0.5, verbose=False)
    svg_content = buf.getvalue()
    buf.close()

    html = f"<div>{svg_content}</div>"
    return html
```

Now you get to call `fmt()` to modify the column you want to apply the plotting function to.

```{python}
gt.fmt(fns=create_plot_plotnine, columns="Plot")
```

Nice! But that was a sizable chunk of code to create plots comprised of one bar each. Still, when you come across a use case that necessitates more detailed plots, a comprehensive plotting package like `plotnine` will probably be your best bet. Imagine we are passing in a list of tuples and want to generate a scatterplot, writing all of those as `svg.py` elemnts or direct HTML would be quite cumbersome.


## A Lightweight Approach: Svg.py


```{python}
from svg import SVG, Rect, Line

height = 30
width = 50


def create_plot_svg_py(val: int) -> str:
    canvas = SVG(
        width=width,
        height=height,
        elements=[
            Rect(
                x=0,
                y=height / 4,
                width=width * (val / max_legs_value),
                height=height / 2,
                fill="blue",
            ),
            Line(x1=0, x2=0, y1=0, y2=height, stroke="black"),
        ],
    )

    html = f"<div>{canvas}</div>"
    return html
```

Now that we've defined our `create_plot_*` formatting function, the call to `fmt()` is identical to the one above.

```{python}
gt.fmt(fns=create_plot_svg_py, columns="Plot")
```

No saving to a buffer or importing hevay duty plotting functions. This time we built the string and were able to insert into the table with only the help of `svg.py`. See the string below:

```{python}
# | echo: false
create_plot_svg_py(4)
```


## Extreme Minimalism: Adding HTML directly

Notice that in the previous section, `svg.py` just generated a string of HTML. You can do the same thing directly.

```{python}
def create_plot_html(val: int) -> str:
    bar_element = f"""
    <div style="position: absolute;
                width: {width * val / max_legs_value}px;
                height: {height / 2}px;
                background-color: purple;
                margin-top: {height / 4}px;
    "></div>"""

    line_element = """
    <div style="position: absolute;
                top: 0;
                bottom: 0;
                width: 1px;
                background-color: black;
    "></div>"""

    html = f"""
    <div style="position: relative; width: {width}px; height: {height}px;">
        {bar_element}
        {line_element}
    </div>
    """

    return html


# This might be familiar by now
gt.fmt(fns=create_plot_html, columns="Plot")
```

At first glance, encoding HTML in multi-line strings is not pretty, nor is it particularly more lightweight than `svg.py`. Still, it provides a good alternative if you are like me, and insist on being as close to the output as possible.

## Conclusion

How you choose to add plots to Great Tables is up to you.  In writing graphical plotting functions for **gt-extras**, I've personally turned towards an HTML-only approach that I've felt comfortable with in other settings. With that said, I still believe converting table values to graphic output is a task best done with a little bit of help (whether it be `svg-py` or another plotting library will depend on how detailed your plots are).
